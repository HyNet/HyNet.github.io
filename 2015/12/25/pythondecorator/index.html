<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="zhao的整理笔记"/><title>python装饰器 | 实证notebook</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">python装饰器</h1><a id="logo" href="/">实证notebook</a><p class="description">zhao的整理笔记</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">python装饰器</h1><div class="post-meta">2015-12-25 | <span class="categories">分类于<a href="/categories/python/"> python</a></span></div><div class="post-content"><h2 id="u5F15_u8A00"><a href="#u5F15_u8A00" class="headerlink" title="引言"></a>引言</h2><p>本文主要梳理了Python decorator的实现思路，解释了为什么Python decorator是现在这个样子。</p>
<h2 id="u5173_u4E8E_u4EE3_u7406_u6A21_u5F0F_u3001_u88C5_u9970_u6A21_u5F0F"><a href="#u5173_u4E8E_u4EE3_u7406_u6A21_u5F0F_u3001_u88C5_u9970_u6A21_u5F0F" class="headerlink" title="关于代理模式、装饰模式"></a>关于代理模式、装饰模式</h2><p>设计模式中经常提到的代理模式、装饰模式，这两种叫法实际上是说的同一件事，只是侧重点有所不同而已。</p>
<p>这两者都是<strong>通过在原有对象的基础上封装一层对象，通过调用封装后的对象而不是原来的对象来实现代理/装饰的目的</strong>。</p>
<p>例如：（以Java为例）<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CountProxy</span> <span class="title">implements</span> <span class="title">Count</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CountImpl countImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CountProxy</span>(<span class="params">CountImpl countImpl</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.countImpl = countImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCount</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"事务处理之前"</span>);</span><br><span class="line">        <span class="comment">// 调用委托类的方法;</span></span><br><span class="line">        countImpl.queryCount();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"事务处理之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCount</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"事务处理之前"</span>);</span><br><span class="line">        <span class="comment">// 调用委托类的方法;</span></span><br><span class="line">        countImpl.updateCount();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"事务处理之后"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中<code>CountProxy</code>是对<code>CountImpl</code>的封装。<br>使用者通过<code>CountProxy.queryCount</code>方法来调用<code>CountImpl.queryCount</code>方法，这被称为代理，即<code>CountProxy</code>是代理类，<code>CountImpl</code>是被代理类。<br>在<code>CountProxy.queryCount</code>方法中，可以在<code>CountImpl.queryCount</code>方法调用之前和之后添加一些额外的操作，被称为装饰，即<code>CountProxy</code>是装饰类，<code>CountImpl</code>是被装饰类。</p>
<p>如果强调通过<code>CountProxy</code> 对<code>CountImpl</code>进行代理的作用，则称为代理模式；<br>如果强调通过<code>CountProxy</code> 对<code>CountImpl</code>增加额外的操作，则称为装饰模式；</p>
<p>不论是哪种称呼，其本质都在于对原有对象的封装。<br>其封装的目的在于增强所封装对象的功能或管理所封装的对象。</p>
<p>从上面的例子也可以发现，代理/封装所围绕的核心是<strong>可调用对象</strong>（比如函数）。</p>
<h2 id="Python_u4E2D_u7684_u4EE3_u7406/_u88C5_u9970"><a href="#Python_u4E2D_u7684_u4EE3_u7406/_u88C5_u9970" class="headerlink" title="Python中的代理/装饰"></a>Python中的代理/装饰</h2><p>Python中的可调用对象包括函数、方法、实现了<strong>call</strong>方法的类。<br>Python中的函数也是对象，可以作为高阶函数的参数传入或返回值返回。<br>因此，当代理/装饰的对象是函数时，可以使用高阶函数来对某个函数进行封装。<br>例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_count_proxy</span><span class="params">(fun, name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'do something before'</span>)</span><br><span class="line">    rv = fun(name, age)</span><br><span class="line">    print(<span class="string">'do something after'</span>)</span><br><span class="line">    <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_count</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'name is %s, age is %d'</span> % (name, age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">query_count_proxy(query_count, <span class="string">'Lee'</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></p>
<p>但是，这个例子中，<code>query_count</code>函数作为参数传入<code>query_count_proxy</code>函数中，并在<code>query_count_proxy</code>函数中被调用，其结果作为返回值返回。这就完成了代理的功能，同时，在调用<code>query_count</code>函数的前后，我们还增加了装饰代码。<br>但是，<code>query_count_proxy</code>的函数参数与<code>query_count</code>不一样了，理想的代理应该保持接口一致才对。</p>
<p>为了保持一致，我们可以利用高阶函数可以返回函数的特点来完成：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_count_proxy</span><span class="params">(fun)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(name, age)</span>:</span></span><br><span class="line">        print(<span class="string">'do something before'</span>)</span><br><span class="line">        rv = fun(name, age)</span><br><span class="line">        print(<span class="string">'do something after'</span>)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_count</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    print(<span class="string">'name is %s, age is %d'</span> % (name, age))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">query_count_proxy(query_count)(<span class="string">'Lee'</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></p>
<p>修改后的例子，<code>query_count_proxy</code>仅负责接受被代理的函数q<code>uery_count</code>作为参数，同时，返回一个函数对象<code>wrapper</code>作为返回值，真正的封装动作在<code>wrapper</code>这个函数中完成。</p>
<p>此时，如果调用<code>query_count_proxy(query_count)</code>就得到了<code>wrapper</code>函数对象，则，执行<code>query_count_proxy(query_count)(&#39;Lee&#39;, 20)</code>就相当于执行了<code>wrapper(&#39;Lee&#39;, 20)</code>。</p>
<p>但是可以看到，<code>query_count_proxy(query_count)(&#39;Lee&#39;, 20)</code>这种使用方法，仍然不能保证一致。</p>
<p>为了保持一致，我们需要利用Python中对象与其名称可以动态绑定的特点。<br>不使用<code>query_count_proxy(quer_count)(&#39;Lee&#39;, 20)</code>来调用代理函数，而是使用下面两句：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_count = <span class="function"><span class="title">query_count_proxy</span><span class="params">(query_count)</span></span></span><br><span class="line"><span class="function"><span class="title">query_count</span><span class="params">(<span class="string">'Lee'</span>, <span class="number">20</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>执行<code>query_count_proxy(query_count)</code>生成<code>wrapper</code>函数对象，将这个对象通过<code>query_count = query_count_proxy(query_count)</code>绑定到<code>query_count</code>这个名字上来，这样执行<code>query_count(&#39;Lee&#39;, 20)</code>时，其实执行的是<code>wrapper(&#39;Lee&#39;, 20)</code>。</p>
<p>这么做的结果就是：使用代理时调用<code>query_count(&#39;Lee&#39;, 20)</code>与不使用代理时调用<code>query_count(&#39;Lee&#39;, 20)</code>对使用者而言保持不变，不用改变代码，但是在真正执行时，使用的是代理/装饰后的函数。</p>
<p>这里，基本利用Python的高阶函数及名称绑定完成了代理/装饰的功能。<br>还有什么不理想的地方呢？<br>对，就是<code>query_count = query_count_proxy(query_count)</code>，因为这句既不简洁，又属于重复工作。<br>Python为我们提供了语法糖来完成这类的tedious work。<br>方法就是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="decorator">@query_count_proxy</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_count</span><span class="params">(name, age)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name is %s, age is %d'</span> % (name, age)</span><br></pre></td></tr></table></figure></p>
<p><code>query_count = query_count_proxy(query_count)</code>就等同于在定义<code>query_count</code>函数的时候，在其前面加上<code>@query_count_proxy</code>。</p>
<p>Python看到这样的语法，就会自动的执行<code>query_count = query_count_proxy(query_count)</code>进行<strong>name rebinding</strong></p>
<h2 id="u8865_u5145"><a href="#u8865_u5145" class="headerlink" title="补充"></a>补充</h2><p>以上就是Python实现可调用对象装饰的核心。<br>可调用对象包括函数、方法、实现了<strong>call</strong>方法的类，上述内容只是针对函数来解释，对于方法、实现了<strong>call</strong>方法的类，其基本原理相同，具体实现略有差别。</p>
<p>本文系作者原创，如有转载请注明出处。<br>由于水平精力有限，如有错误欢迎指正。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2015/12/25/nginxqueue/" class="pre"><i class="icon-previous">nginx源码分析：双向链表</i></a><a href="/2015/12/25/pythonproperty/" class="next">python 类属性与实例属性<i class="icon-next"></i></a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="https://HyNet.github.io"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/nginxlist/">nginx源码分析：链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/nginxpool/">nginx内存池</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/nginxqueue/">nginx源码分析：双向链表</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/pythondecorator/">python装饰器</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/pythonproperty/">python 类属性与实例属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/ngxconfig/">nginx源码分析：配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/ngx_modleconfig2/">nginx 源码分析：从模块到配置(下)</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/25/ngx_array/">nginx源码分析-ngx_array</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">实证notebook.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script>
<script src="/js/jquery.fancybox.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"></div></body></html>